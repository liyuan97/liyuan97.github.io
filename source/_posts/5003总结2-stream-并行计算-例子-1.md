---
title: 5003æ€»ç»“2 stream&å¹¶è¡Œè®¡ç®—-ä¾‹å­
date: 2019-12-26 20:43:15
tags: 
- å¤ä¹  
- spark
- å¹¶è¡Œè®¡ç®—
- 5003
---

Streamingæ˜¯å¤„ç†æ•°æ®æµçš„APIã€‚
ä¸‹é¢ç›´æ¥é€šè¿‡ä¾‹å­ï¼Œæ„Ÿå—streamingçš„æœºåˆ¶ã€‚

![](https://liyuanimage.oss-cn-beijing.aliyuncs.com/img/20191123213735.png)
<!-- more -->
# ä¾‹1 ä»é”®ç›˜è¾“å…¥æ–‡æœ¬ï¼Œç»Ÿè®¡è¯é¢‘
![](https://liyuanimage.oss-cn-beijing.aliyuncs.com/img/20191123220112.png)

# ä¾‹2.1 ä»æ–‡ä»¶è¾“å…¥ï¼Œç»Ÿè®¡è¯é¢‘
![](https://liyuanimage.oss-cn-beijing.aliyuncs.com/img/20191123222512.png)

# ä¾‹2.2 å¯¹è¯çš„æ„Ÿæƒ…å€¼æ’åº
![](https://liyuanimage.oss-cn-beijing.aliyuncs.com/img/20191123230557.png)

# ä¾‹2.3 stageï¼Œç»Ÿè®¡æ‰€æœ‰è¯é¢‘

ä¸Šé¢çš„ä¾‹å­2.1 ä»…ä»…æ˜¯ç»Ÿè®¡æ¯ä¸€ä¸ªè¾“å…¥éƒ¨åˆ†çš„è¯é¢‘ï¼Œæ„ä¹‰ä¸å¤§
é€šè¿‡`updateStateByKey()`å¯ä»¥å®ç°å¯¹æ‰€æœ‰æ•°æ®çš„ç»Ÿè®¡ã€‚

![](https://liyuanimage.oss-cn-beijing.aliyuncs.com/img/20191123231336.png)

`updateStateByKey()`éœ€è¦å®šä¹‰ä¸€ä¸ªå‡½æ•°ï¼Œå‡½æ•°çš„è¾“å…¥æ˜¯ä¸Šæ¬¡çš„å’Œè¿™æ¬¡çš„rddï¼Œè¿™é‡Œçš„streamingçš„ç²¾é«“ï¼Œéœ€è¦å¥½å¥½ç†è§£ã€‚



---
# ç®—æ³•åº”ç”¨1ï¼šè“„æ°´æ± æŠ½æ ·Reservoir Sampling

## ç®—æ³•è¿‡ç¨‹

è“„æ°´æ± é‡‡æ ·ç®—æ³•ï¼ˆReservoir Samplingï¼‰äº†ã€‚å…ˆè¯´ä¸€ä¸‹ç®—æ³•çš„è¿‡ç¨‹ï¼š

- å‡è®¾æ•°æ®åºåˆ—çš„è§„æ¨¡ä¸º  ğ‘›ï¼Œéœ€è¦é‡‡æ ·çš„æ•°é‡çš„ä¸º  ğ‘˜ã€‚
- é¦–å…ˆæ„å»ºä¸€ä¸ªå¯å®¹çº³  ğ‘˜  ä¸ªå…ƒç´ çš„æ•°ç»„ï¼Œå°†åºåˆ—çš„å‰  ğ‘˜  ä¸ªå…ƒç´ æ”¾å…¥æ•°ç»„ä¸­ã€‚
- ç„¶åä»ç¬¬  ğ‘˜+1  ä¸ªå…ƒç´ å¼€å§‹ï¼Œä»¥  ğ‘˜/ğ‘›  çš„æ¦‚ç‡æ¥å†³å®šè¯¥å…ƒç´ æ˜¯å¦è¢«æ›¿æ¢åˆ°æ•°ç»„ä¸­ï¼ˆæ•°ç»„ä¸­çš„å…ƒç´ è¢«æ›¿æ¢çš„æ¦‚ç‡æ˜¯ç›¸åŒçš„ï¼‰ã€‚ å½“éå†å®Œæ‰€æœ‰å…ƒç´ ä¹‹åï¼Œæ•°ç»„ä¸­å‰©ä¸‹çš„å…ƒç´ å³ä¸ºæ‰€éœ€é‡‡å–çš„æ ·æœ¬ã€‚
> è¿™æ ·å°±å¯ä»¥å¯¹ä»»æ„é•¿åº¦çš„æ•°æ®æŠ½æ ·ï¼Œå¯ä»¥å®ç°streaming. ä¸éœ€è¦è€ƒè™‘æ–‡ä»¶é•¿åº¦ã€‚

ç®€å•è¯æ˜ï¼š
![](https://liyuanimage.oss-cn-beijing.aliyuncs.com/img/20191124085220.png)

å®Œæ•´è¯æ˜éœ€è¦ç”¨åˆ°FIsher-Yates shuffleã€‚

# ç®—æ³•åº”ç”¨2ï¼šO(n)æ—¶é—´ï¼ŒO(1)ç©ºé—´ï¼Œå¯»æ‰¾Majorityçš„å…ƒç´ (n>N/2)

ç®—æ³•æè¿°ï¼š
åªç”¨ç©ºé—´å¤æ‚åº¦O(1)ï¼Œå»å¯»æ‰¾æ•°ç»„å†…æœ‰æ²¡æœ‰å‡ºç°æ¬¡æ•°å¤§äºä¸€åŠçš„å…ƒç´ ã€‚

ç®—æ³•è¿‡ç¨‹ï¼š
> éå†æ‰€æœ‰å…ƒç´ ï¼šè®°å½•æ–°å‡ºç°å…ƒç´ çš„æ¬¡æ•°ï¼Œå¦‚æœä¸‹ä¸€ä¸ªä¸è®°å½•ç›¸åŒï¼Œå°±ï¼‹1ï¼Œä¸åŒå°±-1ï¼Œéå†å®Œæˆï¼Œä¼šä¿ç•™ä¸€ä¸ªå€™é€‰é¡¹
> éå†æ‰€æœ‰å…ƒç´ ï¼šç»Ÿè®¡åˆšæ‰å€™é€‰é¡¹å‡ºç°çš„æ¬¡æ•°nä»¥åŠNï¼ŒéªŒè¯n>N/2åˆ™éªŒè¯æˆåŠŸï¼Œå¦‚æœn<=N/2ï¼Œåˆ™æ— Majority



# ç®—æ³•åº”ç”¨3ï¼šGMç®—æ³• Heavy hitters

Misra-Gries (MG) algorithm finds up to k items that occur more than 1/k fraction of the time in a stream.
æ‰¾åˆ°é¢‘ç‡è¶…è¿‡1/kçš„å…ƒç´ .
ç®—æ³•ï¼š
> åˆå§‹åŒ–kä¸ªå€™é€‰é¡¹ï¼Œå¯¹ä¹‹åçš„æ¯ä¸ªå…ƒç´ ï¼š
> 
> - å¦‚æœå…ƒç´ å·²ç»è¢«è®°å½•äº†ï¼Œcount++
> - å¦‚æœæ²¡æœ‰è®°å½•ï¼Œå¦‚æœå€™é€‰é¡¹<kï¼Œé‚£å°±è®°å½•ä»–
> -  å¦‚æœæ²¡æœ‰è®°å½•ï¼Œå¦‚æœå€™é€‰é¡¹=kï¼Œé‚£å°±å¯¹æ¯ä¸ªå€™é€‰é¡¹count--
> 
> éå†å®Œæˆï¼Œè¿”å›å€™é€‰é¡¹

# ç®—æ³•åº”ç”¨4ï¼šå¹¶è¡Œè®¡ç®—TOPn, æ—¶é—´å¤æ‚åº¦æ»¡è¶³O(n/p*log k) 

åŸé¢˜ï¼š
> Given an RDD storing a list of n integers (unordered), design a divide-and-conquer algorithm to find the k largest integers in the RDD. All workers must run in parallel. For full marks, each worker should run in time O(n/p * log k) time, where p is the number of workers.
> Hint: Use a priority queue at each worker for maximum efficiency.

å½“çœ‹åˆ°log Kå’Œpriority queueå°±çŸ¥é“è¦ä½¿ç”¨å †æ’åºäº†ã€‚
åˆ†æˆpä¸ªworkerï¼Œæ¯ä¸ªworkeræœ‰O(n/p)çš„å€¼ï¼Œæ¯ä¸€ä¸ªworkç»´æŠ¤ä¸€ä¸ªæœ€å¤§Kå †ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯O(log k). 

è€å¸ˆç»™çš„ç­”æ¡ˆï¼š
> Partition the integers evenly so that each worker receives O(n/p) values. On each worker, maintain a min-heap of size k. Inserting an element to the heap costs O(log k) time.
For each value, insert it to the heap if it is larger than the current min of the heap. Pop the minimum item if there are more than k items in the heap. By making one pass over all the values in each worker, we get the k largest integers out of the values of this worker. This can be done in O(n/p log k) time.
Then we merge the results by sending the top k of each partition to the same worker, which is at most kp values. The worker finds the largest k integers among these kp values and report it.

ä»£ç 
```py
import heapq  # å¼•å…¥æœ€å¤§å †çš„åŒ…
  
rdd = sc.parallelize(xrange(0,1000,2))   #ç”Ÿæˆrdd
k = 10  
  
def topk(it):        #å¯¹äºæ¯ä¸€ä¸ªåˆ†åŒºçš„n/pä¸ªå€¼
    h = []  
    for i in it:     #éå†æ¯ä¸€ä¸ªå€¼
        # check if we should insert i  
        if (not h) or (i > h[0]):   #å¦‚æœhä¸ºç©ºæˆ–è€…æ–°æ¥çš„å¤§äºhé‡Œé¢æœ€å¤§çš„
            heapq.heappush(h,i)     #æŠŠè¿™ä¸ªå…ƒç´ æ’å…¥åˆ°h
            if len(h) > k:          #é•¿åº¦å¤§äºk
                heapq.heappop(h)    #å¼¹å‡ºhä¸­æœ€å°çš„
    for i in xrange(len(h)):        #éå†æ¯ä¸€ä¸ªå€¼
        yield heapq.heappop(h)      #ä»å°åˆ°å¤§ä¾æ¬¡å¼¹å‡ºè¿”å›åˆ°ä¸Šä¸€å±‚
        
print(list(topk(rdd.mapPartitions(topk).collect()))) #å¯¹äºåˆ†åŒºä½¿ç”¨ï¼Œå†æ•´ä½“ä½¿ç”¨
```

----
ç”¨å®ä¾‹æ€»ç»“äº†å‡ ä¸ªsteamingå’Œå¹¶è¡Œè®¡ç®—çš„åŸºç¡€çŸ¥è¯†ç‚¹ï¼Œè·¯æ¼«æ¼«å…®ã€‚